from pathlib import Path
from typing import Union
from Denabase.cnf.cnf_types import CnfDocument
from Denabase.core.errors import CNFError

def read_dimacs(path: Union[str, Path]) -> CnfDocument:
    """
    Robustly reads a DIMACS CNF file.
    Supports comments (c), problem lines (p), and multiple clauses per line.
    """
    path = Path(path)
    clauses = []
    num_vars = 0
    num_clauses_expected = 0
    
    try:
        with open(path, "r") as f:
            current_clause = []
            for line in f:
                line = line.strip()
                if not line or line.startswith('c'):
                    continue
                
                parts = line.split()
                if parts[0] == 'p':
                    if len(parts) >= 4 and parts[1] == 'cnf':
                        num_vars = int(parts[2])
                        num_clauses_expected = int(parts[3])
                    continue
                
                for p in parts:
                    val = int(p)
                    if val == 0:
                        if current_clause:
                            clauses.append(current_clause)
                            current_clause = []
                    else:
                        current_clause.append(val)
            
            # Catch trailing clause if missing terminal 0
            if current_clause:
                clauses.append(current_clause)
                
    except Exception as e:
        raise CNFError(f"Failed to read DIMACS from {path}: {e}")

    # Re-calculate num_vars if not provided or inconsistent
    max_var = 0
    if clauses:
        max_var = max(abs(lit) for c in clauses for lit in c)
    num_vars = max(num_vars, max_var)

    return CnfDocument(num_vars=num_vars, clauses=clauses)

def write_dimacs(doc: CnfDocument, path: Union[str, Path], canonical: bool = True):
    """
    Writes a CnfDocument to a DIMACS file.
    Optionally enforces canonical ordering.
    """
    path = Path(path)
    clauses = doc.get_canonical_clauses() if canonical else doc.clauses
    
    try:
        with open(path, "w") as f:
            f.write(f"c Generated by Denabase\n")
            f.write(f"p cnf {doc.num_vars} {len(clauses)}\n")
            for clause in clauses:
                f.write(" ".join(map(str, clause)) + " 0\n")
    except Exception as e:
        raise CNFError(f"Failed to write DIMACS to {path}: {e}")

# Aliases for backward compatibility with skeleton code
load_cnf = read_dimacs
save_cnf = write_dimacs
